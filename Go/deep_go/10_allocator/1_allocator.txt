
     Escape analysis --- процесс во время компиляции программы, который 
определяет где в программе создаются объекты и как они используются.
Определяет где размещать - в куче или стеке.

Go старается аллоцировать объекты на стеке, если это возможно.
Аллокация на стеке работает быстрее, потому что:
    1. Стек растет и уменьшается не иак часто.
    2. Простой алгоритм добавления (просто подвинуть стек поинтер при добавлении или удалении).
    3. Кэш дружелюбность.
    4. Мы не грузим GC дополнительной работой. GC не занимается стеками.
    5. Стековую память не нужно освобождать по частям.
        Стек горутины фактически можно рассматривать как один блок памяти
        поэтому он будет освобожден как одно целое при завершении горутины.
    6. Фрагментация. Меньше аллокаций памяти.
    7. Чтоб расширять хип надо стучаться в ядро операционной системы.


Однако, если компиляьтор не сиожет доказать что переменная 
не ссылается  после выхода из функции, тогда это будет проалоцированно в куче.
Чтобы избежать проблемы висячих указателей.

// ===========================================

    Объект аллоцируется на стеке если:
    ----------------------------------

1. Максимальный размер переменной не более 10 мб.
MaxStackSize = int(10 * 1024 * 1024)

2. Создание имплисит переменной.
p := new(T)
p := &T{}
p := make([]T, n)
s := []byte("...")

3. Максимальный размер массива не более 10 мб.
4. Максимальный размер среза 64 кб.
 
// ===========================================

    Объект едет в хип если:
    -----------------------

1. Если Escape analysis не может доказать что на объект 
    никто не будет ссылаться за пределами функции.

2. Если достаточно большой размер.

3. Если одно из полей структуры перемещается в кучу,
    то вся структура также перемещается в кучу.

4. Если один из элементов массива перемещается в кучу,
    то вся элементы массива также перемещается в кучу.

5. Если один из элементов среза перемещается в кучу,
    то вся элементы также перемещается в кучу.
 
// ===========================================

    Run with flags to analyse.
    --------------------------


$ go build -gcflags '-l -m'

 
// ===========================================

Есть накладные расходы когда стек растет или уменьшается.

Стек горутины начинается с 2 кб.
stackMin = 2048

В последних версиях Go сделали Contigious stack - расти будет так как и со срезами,
выделяем участок памяти в 2 раза больше и копируем туда со старой памяти.

Стек горутины может сужаться, например когда используются 25% памяти. 

 
// ===========================================

    Max stack size.
    ---------------

1 GB   --- for 64-bit system
259 MB --- for 32-bit system

 
// ===========================================

    Sync Pool.
    ----------

Набор инициализированных и готовых к использованию объектов:
    - когда системе требуется объект, он не создается, а берется из пула
    - когда объект больше не нужен, он не уничтожается, а возвращается в пул


type Pool struct {
    New func() any
}

func (p *Pool) Get() any    // забирает объект из пула
func (p *Pool) Put(x any)   // кладет в пул

Можно использовать из разных горутин.
 
// ===========================================

    Region-based memory management. Арены.
    --------------------------------------

Арены --- предназначены для батчевой обработки данных.
Когда в памяти много всего создается по ичереди
и мы хотим очистить все одним махом, не нагружая GC.

Арены предоставляют собой набор чанков по 8 мб,
которые объединяются в связанный список.
Начинается с одного чанка 8 мб.

Арену можно использовать р рамках 1 горутины.

 
// ===========================================