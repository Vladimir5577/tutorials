Мусор --- это неиспользуемая память программы, 
которую следует освободить для дальнейшего использования.

Если приложение живет пару часов и ему хватает памяти,
то мусор можно не собтрать.

Автоматический режим:
    1. Подсчет ссылок.
    2. Трассирование.

Подсчет ссылок ищет мертвые объекты, а трейсинг ищет живые.


// =============================================

    Подсчет ссылок.
    ---------------

Каждый объект содержит счетчик количества
ссылок на него, используемых другими объектами.
Когда этот счетчик опускается до нуля,
это означает, что объект стал недоступным,
и его можно освободить.

Преимущества;
    1. Не нужно запускать никаких процессов сборки мусора.

Недостатки:
    1. Делает лишнюю работу по увеличению и уменьшению счетчика ссылок.
    2. Нужна синхронизация со счетчиком ссылок.
    3. Дополнительная память на хранение счетчика.
    4. Синхронное освобождение последовательности элементов
        например множество элементов связанного списка.
    5. Проблемы циклических ссылок (абстрагировать их
        не получиться, программисту придется знать о них и ими управлять)

// =============================================

    Трейсинг.
    ---------

В отличии от подсчета ссылок, трейсинг занимается 
противоположным - он ищет живые объекты.

Останавливаются все потоки, без синхронизации
обходится граф ссылок, помечаются все используемые объекты,
после чего непомеченные объекты удаляются.

// =============================================

    Самый примитивный сценарий работы. STW (Stop-The-World).
    -------------------------------------------------------

1. Останавливаются все потоки (мутаторы)
2. Без синхронизации обходится граф ссылок (можно параллельно).
3. Помечаются все используемые объекты.
4. После чего непомеченные объекты удаляются.

Чем больше куча, тем больше паузы!


    №1 Как остановить все потоки?
    -----------------------------

Можно всавить точки в код, благодаря которым поток может понять,
что нужно остановиться, запретить страницу для чтения 
при помощи mprotect.

Глобальные переменные помечены серым т.к. они ссылаются в хип.

    №2 Обойти граф ссылок - фаза mark.
    ----------------------------------

Начнем обход графа со стеков потоков и с глобальных переменных,
формируя root set для обхода.

2 способа обхода графа:
    1. В ширину.
    2. В глубину.

Граф обходится многопоточно в глубину.

При обходе красим граф в три цвета:
                         ``````````
1. Черный --- исследованный объект (объект посещен и все ссылки
                которые идут из него исследованны).
2. Серый  --- ожидающий мсследрвания объект (узнали про лбъект,
                но его еще не исследовали, не все ссылки от него прошлись).
3. Белый  --- неисследованный объект (не знаем еще про объект).
    
Tree color invariant - не бывает ссылок из черногог объекта белый.
Из черного объекта никогда не будем ссылоться в белый.
Из черного -> в серый.

Те объекты до которых не дошли --- мусор (белые объекты).

Граф красим в три цвета для - типичный способ поиска циклов в графе.
Если начали с серой вершины и прмшли опять в серую - значит 
есть еще ребра для исследования.
    

    №3 Дальше есть две альтернативы.
    --------------------------------

1. Sweep   --- освободить то что белого цвета.
2. Copying --- перенести живые объекты в новое место,
                    а старое освободить, чтобы не было фрагментации.


// =============================================

Можно обходить не всю кучу, а часть (поколения), 
так как большинство объектов удаляются "молодыми".
Хорошо бы отделить объекты по времени жизни,
те которые живут долго, будем их обходить редко,
а молодые будем обходить чаще.

// =============================================

Concurrent GC --- можно запустить поток CG одновременно,
который выполняет сбор мусора вместе с мутаторами.

// =============================================

    ======================================
    || Go GC (состоит из трех пунктов): ||
    ======================================

    * Mark and Sweep --- алгоритм GC
    * Трехцветный    --- алгоритм рзметки
    * Конкурентный   --- выполняется конкурентно с основной программой
                            с использованием барьеровзаписи.

// =============================================

В настоящее время фракция CPU, потребляемая воркерами GC,
жестко зафиксирована на уровне 25%. Если GC понимает, что не справляется
с потоком мусора, он может слегка притормозить новые аллокации,
заставляя некоторые горутины тратить часть времени на сборку мусора.

Эта оптимизация называется Mark Assist и позволяет
довести потребляемую GC фракцию до 30%.

// =============================================

    Когда запускается сборщик мусора в Go?
    ---------------------------------------

1. Превышение динамического лимита куча, 
    установленного с помощью переменной GOGC.
2. Прошло 2 минуты без GC --- если вы ничего не
    аллоцировали за это время, GC все равно запуститься
    раз в 2 минуты (за это отвечает sysmon).
3. Ручной запуск с помощью runtime.GC() --- если
    сделать этот вызов, когда GC уже запущен,
    то по достижении фазы sweep он запуститься заново.\


// =============================================

    Death Spiral.
    -------------

Можно перестараться с GOGC и столкнуться со спиралью смерти.

    Нужно больше памяти ---> Чаще запускаем GC ---> Тратим больше CPU ---
        /|\                                                              |
          --- Запросы копятся в очередях   <---   Throughput падает   <---


// =============================================

    GOMEMLIMIT
    -----------

Учитывая всю память потребляемую приложением (не только кучу)
и ориентируясь на заданную верхнюю границу потребления памяти,
рантайм будет чаще вызывать сборку мусора и более агрессивно
возвращать память операционной системе.

Выставить лимит можно при помощи переменной 
окружения, GOMEMLIMIT=2750MiB

Чтобы избежать скатывания GC в спираль смерти для GOMEMLIMIT,
вводиться искусственное ограничение на потребление сборщиком
мусора CPU - оно не превысит 50% даже в самых жестких ситуащиях,
когда мусора очень много, а память почти исчерпана.

В этом случае приложение сможет продолжить аллоцировать новую
память, что с большой вероятностью приведет к преодолению лимита
(в этом смысле он является мягким, так как позволяет 
использовать память сверх лимита).


// =============================================

    GC ALGORITHM PHASES
    -------------------

1. Sweep termination --- предадущая фаза не окончена, нужно дождаться окончания
    - Stop the World
    - Завершение всех sweep фаза
    - Удаление остатков

2. Mark phase
    - Включает write barrier
    - Start the World
    - Запускаем сканирование глобальным переменных и стеков
        (при сканировании стека, горутина приостанавливается)
    - Раскрашиваем объекты в три цвета

3. Mark termination
    - Stop the World
    - Дожидаемся обработки последних задая из очереди
    - Завершаем разметку

4. Sweep
    - Отключаем write barrier
    - Start the World
    - Очищаем ресурсы в фоне

Текущая стадия работы сборщика мусора 
храниться в глобальной переменной GCPHASE


// =============================================

    Кто выполняет сборку мусора?
    ----------------------------

"М" --- может использовать пользовательскую горутину,
а также может тспользовать горутину GC.

// =============================================

    Чтоб eменьшить нагрузку на GC --- надо стараться 
переиспользовать выделенную память и больше аллоцировать
на стеке, вместо кучи.


// =============================================