Мусор --- это неиспользуемая память программы, 
которую следует освободить для дальнейшего использования.

Если приложение живет пару часов и ему хватает памяти,
то мусор можно не собтрать.

Автоматический режим:
    1. Подсчет ссылок.
    2. Трассирование.

Подсчет ссылок ищет мертвые объекты, а трейсинг ищет живые.


// =============================================

    Подсчет ссылок.
    ---------------

Каждый объект содержит счетчик количества
ссылок на него, используемых другими объектами.
Когда этот счетчик опускается до нуля,
это означает, что объект стал недоступным,
и его можно освободить.

Преимущества;
    1. Не нужно запускать никаких процессов сборки мусора.

Недостатки:
    1. Делает лишнюю работу по увеличению и уменьшению счетчика ссылок.
    2. Нужна синхронизация со счетчиком ссылок.
    3. Дополнительная память на хранение счетчика.
    4. Синхронное освобождение последовательности элементов
        например множество элементов связанного списка.
    5. Проблемы циклических ссылок (абстрагировать их
        не получиться, программисту придется знать о них и ими управлять)

// =============================================

    Трейсинг.
    ---------

В отличии от подсчета ссылок, трейсинг занимается 
противоположным - он ищет живые объекты.

Останавливаются все потоки, без синхронизации
обходится граф ссылок, помечаются все используемые объекты,
после чего непомеченные объекты удаляются.

// =============================================

    Самый примитивный сценарий работы. STW (Stop-The-World).
    -------------------------------------------------------

1. Останавливаются все потоки (мутаторы)
2. Без синхронизации обходится граф ссылок (можно параллельно).
3. Помечаются все используемые объекты.
4. После чего непомеченные объекты удаляются.

Чем больше куча, тем больше паузы!


    №1 Как остановить все потоки?
    -----------------------------

Можно всавить точки в код, благодаря которым поток может понять,
что нужно остановиться, запретить страницу для чтения 
при помощи mprotect.

Глобальные переменные помечены серым т.к. они ссылаются в хип.

    №2 Обойти граф ссылок - фаза mark.
    ----------------------------------

Начнем обход графа со стеков потоков и с глобальных переменных,
формируя root set для обхода.

2 способа обхода графа:
    1. В ширину.
    2. В глубину.

Граф обходится многопоточно в глубину.

При обходе красим граф в три цвета:
                         ``````````
1. Черный --- исследованный объект (объект посещен и все ссылки
                которые идут из него исследованны).
2. Серый  --- ожидающий мсследрвания объект (узнали про лбъект,
                но его еще не исследовали, не все ссылки от него прошлись).
3. Белый  --- неисследованный объект (не знаем еще про объект).
    
Tree color invariant - не бывает ссылок из черногог объекта белый.
Из черного объекта никогда не будем ссылоться в белый.
Из черного -> в серый.

Те объекты до которых не дошли --- мусор (белые объекты).

Граф красим в три цвета для - типичный способ поиска циклов в графе.
Если начали с серой вершины и прмшли опять в серую - значит 
есть еще ребра для исследования.
    

    №3 Дальше есть две альтернативы.
    --------------------------------

1. Sweep   --- освободить то что белого цвета.
2. Copying --- перенести живые объекты в новое место,
                    а старое освободить, чтобы не было фрагментации.


// =============================================

Можно обходить не всю кучу, а часть (поколения), 
так как большинство объектов удаляются "молодыми".
Хорошо бы отделить объекты по времени жизни,
те которые живут долго, будем их обходить редко,
а молодые будем обходить чаще.

// =============================================

Concurrent GC --- можно запустить поток CG одновременно,
который выполняет сбор мусора вместе с мутаторами.

// =============================================

    ======================================
    || Go GC (состоит из трех пунктов): ||
    ======================================

    * Mark and Sweep --- алгоритм GC
    * Трехцветный    --- алгоритм рзметки
    * Конкурентный   --- выполняется конкурентно с основной программой
                            с использованием барьеровзаписи.

// =============================================



// =============================================

1.08