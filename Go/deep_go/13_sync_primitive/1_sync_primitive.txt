
	Разница mutex и atomic.
	-----------------------

mutex  --- блокирующий примитив синхронизации
atomic --- не блокирующий примитив синхронизации

Атомик в мьютексе используется для флага - заблокирован или нет.

// ================================================

Объекты из пакета sync не должны копироваться.
Передача только по указателю.

// ================================================

	Wait Group.
	-----------

type WaitGroup struct { ... }

func (wg *WaitGroup) Add(delta int) 	// increment counter
func (wg *WaitGroup) Done()				// decrement counter
func (wg *WaitGroup) Wait()				// block until counter will = 0

// ================================================

	Mutex.
	------

Mutual Exclusion --- взаимное исключение.

type Mutex struct { ... }

func (m *Mutex) Lock()
func (m *Mutex) Unlock()
func (m *Mutex) TryLock() bool

TryLock - пытаемся захватить мьютекс, и он захвачен,
	то горутина блокируется дотех пор пока этот мьютекс не освободят.

Когда горутина блокируется на мьютексе,
она переходит из состояния Running в Waiting.


// ================================================

	RWMutex.
	--------

Примитив синхронизации, который позволяет
нескольким потокам иметь доступ к общему
ресурсу для чтуния, но блокирует доступ
для записи только одному потоку (горутине).


type RWMutex struct { ... }

func (rw *RWMutex) Lock()			// блоктровать на запись
func (rw *RWMutex) RLock()			// блокировать на чтение
func (rw *RWMutex) RLocker() Locker // возвр интерфейс реализ методы RLock и RUnlock
func (rw *RWMutex) RUnlock()		// разблокировать чтение
func (rw *RWMutex) TryLock() bool	// попробовать заблокировать на запись
func (rw *RWMutex) TryRLock() bool 	// попробовать заблокировать на чтение
func (rw *RWMutex) Unlock()			// разблокировать запись

Много читателей могут заходить в критическую секцию и читать.
Уву только заходит писатель, он ждет когда все читатели покинут
критическую секцию, потом блокирует и начинает писать.

В критической секции писатель может быть только один, 
читателей может быть несколько.

Применяется когда много читают и мало пишут.

// ================================================

 	Data Race.
 	----------

Это несинхронизированное обращение
к одному и тому же участку памяти разных потоков (горутин),
как минимум один из которых осуществляет запись.


// ================================================

	Race Condition.
	---------------

Это ошибка проектирования приложения,
при которой работа системы или приложения зависит  от того,
в каком порядке выполняется части кода.


// ================================================

	DEADLOCK.
	---------

Ситуация когда несколько горутин находятся в состоянии ожидания,
и ни одна не может продолжить свое выполнение.

// ================================================

	Cond.
	-----

	Примитив синхронизации, обеспечивающий блокировани
одного или нескольких потоков до момента поступления сигнала
от другого потока о выполнении некоторого условия.

type Cond struct {
	L Locker
}

func NewCond(l Locker) *Cond
func (c *Cond) Broadcast()
func (c *Cond) Signal()
func (c *Cond) Wait()

// ================================================

	Atomic.
	-------

Атомарные операции которые либо выполняются целиком,
либо не выполняются вовсе.

Атомики работают в 2 раза быстрее чем мьютексы,
и в 15 раз медленнее чем обычные операции операция.

Передаем указатель на участок памяти.

// procedure style

func AddInt32(addr *int32, delta int32) (new int32)		// добавить значение
func LoadInt32(addr *int32) int32 						// получить значение
func StoreInt32(addr *int32, val int32)					// установить значение
func SwapInt32(addr *int32, new int32) (old int32)		// заменить значение и вернуть старое
func CompareAndSwapInt32(addr *int32, old, new int32)	// заменить значение на new если оно равно old

// OOP style

type Bool struct { ... }

func (x *Bool) CompareAndSwap(old, new bool) (swapped bool)
func (x *bool) Load() bool
func (x *Bool) Store(val bool)
func (x *Bool) Swap(new bool) (old bool)


// ================================================
