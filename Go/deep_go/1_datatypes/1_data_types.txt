Тип данных - мнлжество значений и операций, которые могут быть применены 7ад этими значениями.

Примитивные:
-----------

	Логические
		bool
	Строковые
		string
	Числовые
		int8, uint8 (byte), int16, uint16, int32 (rune), uint32, int16, uint16, int64, uint64, int, uint, uintptr
		float32, float64
		complex64, complex128


Coставные:
----------

	1. Указатели
	2. Структуры
	3. Функции
	4. Контейнеры
		* массивы
		* срезы
		* словари
    5. Каналы
    6. Интерфейсы

Каждый тип имеет нулевое значение (zepo value) - по умолчанию.

// ======================================

Data types
-----------
    Basic type
        - numbers
        - strings
        - boolean

    Aggregate type - type that contains another types inside
        - array
        - structs

    Reference type
        - slice
        - map
        - function
        - channel

    Interface type.

// ============================================

Types whose values each is only hosted on one single memory block
    - bool types
    - numeric types
    - pointer types
    - unsafe pointer types
    - struct types
    - array types

Types with multiple memory blocks:
    - slice types
    - map types
    - channel types
    - function types
    - interface types
    - string types

// ============================================

Размерность.
------------

Бит --- минимальная единица измерения --- "ноль" или "один"

Байт --- 8 бит

Машинное слово --- основная единица информации которой оперирует процессор (зависит от архитектуры процессора 32 или 64)

uint8, int8   --- 1 byte
uint16, int16 --- 2 byte
uint, int     --- implementatinl on processor 32 or 64

bool --- 1 byte(8 byte) (not 1 bit) --- because processor works with bytes not with bits

// ============================================

Выравнивание.
-------------

Типы данных в памяти нужно выравнивать!!! 
Это преподготовка для процессора чтоб быстрей читал.
Процессор по выравняному адресу читает ато атомарно.
Потому что ароцессор считывает машинные слова (32 или 64 зависит от процессора).
Процессор с архитектурой 32 может прочитать 4 байтовое значение (или 4 однобайтовых).
Смысл в том чтоб переменная лежала в рамках 1 машинного слова. А не была разделена на 2 слова по половине в каждом.
Чтобы процессор мог прочитать данные фтомарно за 1 раз, ане за два раза в случае переменная частично лежит в двух
машинных словах.

Выравнивание переменных:
    bool, uint8, int8 --- 1 byte
    uint16, int16     --- 2 bytes
    uint32, int 32    --- 4 bytes
    float32, complex64 -- 4
    arrays  --- depends on element types
    structs --- depends on field types
    other types --- size of a native word


// ============================================

Кодирование.
------------

8 bit
00000000 = 0
11111111 = 255

16 bit
0000000000000000 = 0
1111111111111111 = 65535

Разряды битов.
--------------

Старший --- седьмой разряд (крайний левый)
Младший --- нулевой разряд (крайний правый)

Наименьшему соответствует комбинация нулей, а наибольшему комбинация единиц.

    ---------------------------------
    | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
    ---------------------------------

    <--------- старшие разряды
         младшие разряды  --------- >


Отрицательнок число имеет бит знака (старший бит).


// ============================================

Целочисленные литералы.
-----------------------

Двоичный --- префикс 0b или 0B (например 0b100)
Восьмиричный --- префикс 0 или 0о (например 010)
Шестнадцатиричные --- префикс 0х или 0Х (например 0хF)
Мнимые --- суффикс i (например 3i)

Можно использовать в качестве разделителя _ 1_000_000

// ============================================

Указатель.
----------

Указатель --- переменная, диапазон значений которой состоит из адресов ячеек памяти или нулевого адреса (nil)

1 way
pointer := new(int) --- создается объект и возвращается указатель

2 way
var value int
pointer := &value

3 way - inly for structs
pointer := &int{} // compilation error

// ============================================

Pointer --- represents a pointer to an arbitrary type.

4 operation available for type Pointer:
    1. A pointer value of any type can be converted to a pointer.
    2. A pointer can be converted to a pointer value of any type.
    3, A uintptr can be converted to a Pointer.
    4. A Pointer can be converted to a uintptr.

uintptr --- unsigned integer, it is just an integer representation of an address.

// ============================================
// ============================================
// ============================================
// ============================================
