Массив --- структура данных фиксированного размера,
хранящая элементы последовательно одного типа.

Массив --- структура данных у которой есть только
адрес начала, длинна и размер элементов.

// ================================

    Создание массива.
    -----------------

var data1 [5]int                // [0 0 0 0 0] 
var data2 [2][5]int             // [[0 0 0 0 0] [0 0 0 0 0]]
data3 := [...]int{1, 2, 3}      // [1 2 3]
data4 := [5]int{1, 2, 3}        // [1 2 3 0 0]
data5 := [5]int{3: 4}           // [0 0 0 4 0]
data6 := [5]int{2: 5, 6, 1: 7}  // [0 7 5 6 0]

// ==================================

    Обращение к индексу за пределами массива --- это паника.
Потому что в go есть боинд чеки которые проверяют что мы не выходим за пределы.
Также нельзя использовать отрицательные индексы.
data := [3]int{1, 2, 3}
idx := 4
data[idx] // panic 
data[4]   // compilation error


data := [10]int{}
len(data)   // 10
cap(data)   // 10

Массывы можно сравнивать!!!
first := [...]int{1, 2, 3}
second := [...]int{1, 2, 3}

fmt.Println(first == second)
fmt.Println(first != second)

Массив нельзя проверить на nil.
Массив может быть нулевым.
var data [0]int
unsafe.SizeOf(data) // 0

Массив может состоять из пустых структур.
vaa data[10]struct{}
unsafe.SizeOf(data) // 0

J
Отрицательная длинна не может быть
vat data [-1]int    // compilation error

Нельзя создать массив из переменной длинны
length := 10
var data [length]int    // compilation error

Но можно создать массив из constant длинны
const length = 10
var data [length]int  

Функции make() и append() с массивами не работают.


// ==================================

    Как под капотом идет обращение к элементам массива.
    ---------------------------------------------------

array[idx] = *(array + idx * elem_size)

Это индекс умноженный на отступ в памяти элемента.

const elemSize = unsafe.Sizeof(int32(0)) // 4 bytes
array := [...]int32{1, 2, 3}
pointer := unsafe.Pointer(&array)

first := *(*int32)(unsafe.Add(pointer, 0*elemSize))  // => data2[0]
second := *(*int32)(unsafe.Add(pointer, 1*elemSize)) // => data2[1]
third := *(*int32)(unsafe.Add(pointer, 2*elemSize))  // => data2[2]


// ==================================

Массив --- не имеет постоянного расположения в памяти
на все время жизни программы, и может переесжать 
когда растет стэк горутины.

// ==================================

    Iteration.
    ----------
In this case can be "off by one error" --- ошибка неучтенной единицы
for i := 0; i < len(data); i++ {
    // ...
}

    Better to iterate with range:

for _, value := range data{
    // ...
}

for idx, _ := range data{
    // ...
}

for idx := range data{
    // ...
}

for _, _ := range data{
    // ...
}

for range data{
    // ...
}

При итерации в цыкле на каждую итерацию будет создаваться новая переменная.

Если большой массив (например 10 МБ) и итерировать range то это накладно делать большую копию.

data := []int{0, 1, 2}
for value := range data {        // copy of array
    fmt.Println(value)
}

for value := range &data {        // not a copy of array
    fmt.Println(value)
}

for value := range data[:] {        // not a copy of array
    fmt.Println(value)
}


// ==================================

Go аллоцирует массивы в стеке если его размер <= 10 МБ.
Более 10 МБ массив уесжает в хип.
но не забываем про escape analysis

// ==================================

При передаче массива в функцию --- массив копируется.
Если массив большой (10 и более МБ) это будет сложно.
Чтоб избежать больщих копирований можно использовать
указатели или срезы.

// ==================================
