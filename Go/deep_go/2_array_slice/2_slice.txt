
В го за срезом стоит массив.

type slice struct {
    array unsafe.Pointer
    len   int
    cap   int
}

Zero value for slice --- nil.

// ================================================

    Crete slice.
    ------------

data = []int{}          // []               len=0 cap=0                   
data = []int{1, 2}      // [1 2]            len=2 cap=2
data = []int{5: 10}     // [0 0 0 0 0 10]   len=6 cap=6
data = make([]int, 6)   // [0 0 0 0 0 0]    len=6 cap=6
data = make([]int, 3, 6)// [0 0 0 0 0 0]    len=3 cap=6


// ================================================

    Добавление в конец.
    -------------------

// data => [1, 2, 3, 4]
data = append(data)                 // [1 2 3 4]
data = append(data, 5)              // [1 2 3 4 5]
data = append(data, 5, 6, 7)        // [1 2 3 4 5 6 7]
data = append(data, []int{5, 6}...) // [1 2 3 4 5 6]


// ================================================

Обращаться за пределы среза --- паника
data := make([]int, 3)
data[4]     // panic !!!

или с выделенной памятью
data := make([]int, 3, 6)
data[4]     // panic !!!

нельзя отрицательные индексы
data := make([]int, 3, 6)
data[-1]     // panic !!!

при nil срезе нельзя обратиться к элементу
var data []int  // nil slice
_ = data[0]     // panic !!!

нельзя рисать в nil срез

range работает корректно по nil срезу
var data []int
for range data {
}

нельзя создать срез отрицательной длинны
нельзя создать срез где длинни больше чем капасити


// ================================================

    Алгоритм при переполнении капасити:
1. Выделяем больше памяти.
2. Копируем элементы.
3. Добавляем элемент.

// ================================================

При использовании range указанное выражение вычисляется только 1 раз
перед началом цикла.
range копирует объект и затем выполняет итерацию.


// в этом случае слайс будет скопирован и range будет работать с копией
data := []int{0, 1, 2}
for range data {
    data = append(data, 10)  // it will not affected to data and loop will finished
    fmt.Println("Iteration")
}

// в этом случае append будет влиять на первоначальный слайс и будет бесконечрый цыкл
data := []int{0, 1, 2}
for i := 0; i < len(data); i++ {
    data = append(data, 10) 
    fmt.Println("Iteration")
}


// ================================================

    Slicing.
    --------

data := []int{0, 1, 2, 3}

от первого включительно до третьего (не включительно)
temp = data[1:3] // 1, 2

все после второго 
temp = data[2:] // 2, 3

все до третьего (не включая 3-й элемент)
temp = data[:3] // 0, 1, 2

полное копирование
temp = data[:] // 0, 1, 2, 3

// ================================================

При нарезке среза капасити считается дло конца первоначального
Чтоб уменьшить капасити третьим аргументом будет капасити
Но расширить за пределы нельзя

temp = data[1:3:5]

// ================================================

Удаление с конца среза.
------------------------

data := []int{1, 2}
data := data[:len(data) - 1]

Но последний элемент как находился в памяти так и будет находиться.


Удаление с начала среза.
------------------------

data := []int{1, 2}
data = append(data[:0], data[1:]...)

Удаление из середины среза.
---------------------------

data := []int{1, 2, 3, 4, 5}
data = append(data[:2], data[3:]...)

Лучше тзбегать удалений сначала и середины - неэффективно.

// ================================================

Как жить без стэков и очередей?

Кастомная очередь (сеэк).
------------------

// Pop front
data, front = data[1:], data[0]

// Pop back
data, back = data[:len(data) - 1], data[len(data) - 1]

// Push front
data = append([]int{ value }, data...)

// Push back
data = append(data, value)

// ================================================

Go аллоцирует массив среза в стеке, если его размер <= 64 КБ

sliceWithStack := make([]byte, 64<<10) // 64 КБ - в хип не поедет
_ = sliceWithStack

sliceWithHeap := make([]byte, 64<<10+1) // болуу 64 КБ - уесжает в хип
_ = sliceWithHeap

// unknown ...
var sliceSecialCase = []byte{1 << 30: 1} // 1 ГБ
_ = sliceSecialCase

Run with escape analys:
    $ go build -gcflags='-m' . |& grep escape

Когда происходит реалокация --- новый слайс аллоцируется в хип.
Это для того чтоб не засорять стэк при большом количестве реалокаций.

Как проалоцировать массив среза больше 64 КБ в стеке?
- Через массив.
- Можно аллоцировать массив на стеке который будет нге больше 10 МБ,
чтоб затем получить его срез.
Массив на стэке может быть не более 10 МБ.

var array [N]byte
var slice = array[:]

// ================================================

    Очистка среза.
    --------------

Есть несколько способов:

1. Remove all elements --- assign to nil
slice := []int{1, 2, 3, 4, 5}
slice = nil

2. Keep allocated memory:
slice := []int{1, 2, 3, 4, 5}
slice = slice[:0]

3. Zero out elements:
slice := []int{1, 2, 3, 4, 5}
clear(slice)

4. Zero two elements:
slice := []int{1, 2, 3, 4, 5}
clear(slice[1:3])


// ================================================

    Пустые и нулевые срезы.
    -----------------------

Пустой срез --- если len(slice) = 0
Нулевой срез --- если его значение = nil

Best practice: check slice on empty and nil
if len(slice) == 0 {
}


// ================================================

    Сравнение срезов.
    -----------------

Slice is non comparable type!!!
Array is comparable type.

Сравнить срезы можно при помощи рефлексии.

slice1 := make([]int, 10)
slice2 := make([]int, 10)

reflect.DeepEqual(slice1, slice2)

Рефлексия проходит и сравнивает рекурсивно.
Также в пакете slice есть функция Equal()
slice.Equal(slice1, slice2)

Таже можно преобразовать срез в строку и сравнить
fmt.Sprint(slice1) == fmt.Sprint(slice2)

// ================================================

    Копирование срезов.
    -------------------

Функция copy() встроенная.
Число элементов, скопированных в другой слайс,
определяется минимум между:
    - длинной первого среза
    - длинной второго среза

src := []int{1, 2, 3, 4, 5}
dst := make([]int, 3)

copy(dst, src)

fmt.Println(src) // 1 2 3 4 5
fmt.Println(dst) // 1 2 3


// ================================================

    
    Почему функция append() возвращает срез?
    ----------------------------------------

Когда мы изменяем нижележащий массив то ссылка будет изменена.
Нужно присваивать append() в ту же самую переменную.

data := make([]int, 4, 5)
copy := append(data, 5)

fmt.Println(data)       // [0 0 0 0]
fmt.Println(data[:5])   // [0 0 0 0 5]
fmt.Println(copy)       // [0 0 0 0 5]


// ================================================

    Нюансы при обращении к элементам среза - bound check.
    ------------------------------------------------------

Компилятор вставляет следующий код при каждом обращении к элементу среза.
Что делает дополнительный оверхед в цыклах.

if i < 0 || i >= len(slice) {
    panic("index out of bounds")
} 

Since Go toolchain v1.7, the standard Go
compiler has started to support BCE 
(bound check elimination).

BCE can avoid some unnecessary bounds checks, 
so that the standard Go compiler
could generate more efficient programs.