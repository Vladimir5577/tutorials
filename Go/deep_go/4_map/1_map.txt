 Коллизии --- ситуация, когда для разных ключей 
 мы получаем один и тот же результат хэш-функции.

 Конечно коллизии будут, так как мы преобразовываем
 большое множество в маленькое.

 Коллизий не будет если размер входного множества 
 будет меньше выходного, но в большинстве случаев 
 коллизий не избежать, наша задача --- научиться
 работать с хэш коллизиями.

// ===============================================

    Разрешение коллизий.
    --------------------

1. Метод цепочек.
2. Метод открытой адресации.

// ===============================================

    Load factor.
    -------------

Коэффициент загруженности хэш-таблицы,
считается по формуле
f = size / buckets_size

В большинстве реализаций, когда
коэффицикнт больше 0.6 / 0.7 --- происходит переиндексация.

Переиндексация хэш-таблицы практически тоже самое, что
и реалокация памяти для динамичаского массива, но разница
в том, что мы не можем просто бездумно копировать элементы!

Переиндексировать --- пройтись по всем ключам и пересчитать хэш функцию.
Но это медленно.

// ===============================================

Тип данных ключа у мапы должен быть comparable.

Нельзя использовать слайсы и функции в качестве ключей.

// ===============================================

Мап начинается с одного бакета - когда не указывается количество элементов.
dataMap := make(map[int]int)

Но указаеме размера n не означает создание словаря 
с максимальным количеством элементов равнм n 
(выделяется место как для, как минимум n элементов)
dataMap := make(map[int]int, 20)

// ===============================================

Hint Range      Bucket Count        Capacity
0-8             1                   8
9-13            2                   16
14-26           4                   32
27-52           8                   64
53-104          16                  128
105-208         32                  256
209-416         64                  512
417-832         128                 1024
833-1664        256                 2048


// ===============================================

Бакет --- представляет собой массив, фиксированной длинны из 8 элементов.
Некоторые элементы могут быть заняты, некоторые пустые.
0 1 _ 3 4 _ _ _ 

В бакете усть указатель overflow, по умолчанию nil,
если бакет нереполнен то создается новый коллизионный бакет
и присваивается первому бакету указатель на новый коллизионный бакет.
 

type bmap struct {
    tophash  [8]uint8
    keys     [8]int
    values   [8]int
    overflow *bmap
}

tophash --- старшие 8 бит
если после сравнения tophash они совпадают
это значит что ключи могут быть одинаковыми,
затем Go переходит к более медленному процессу
проверка идентичности ключей.

// ===============================================

    Переиндексация при увеличении массива бакетов.
    ----------------------------------------------

Увеличение размеров массива бакетов происходит
при заполненности мапы примерно на 80%,
что примерноравно 6.5 элементов в каждом бакете
(массив увеличивается в 2 раза)

Эвакуация происходит инкрементально и выполняется при записи
и удалении ллючей (за один вызов может перераспределиться
несколько бакетов)

Плюсы:
    - не будет больших пауз во время переиндексации
Минусы:
    - операции записи и удаления будут медленнее в процессе эвакуации
    - при поиске прийдется искать в двух местах



// ===============================================

    Операции.
    ---------

Можно читать из nil мапы
var data map[int]int
_ = data[123]   

Можно удалять из nil мапы
var data map[int]int
delete(data, 123)

Нельзя писать в nil мапу
var data map[int]int
data[123] = 456     // panic 

Можно пройти ранджом по nil мапе
var data map[int]int
for range data {
}

Можно перезаписать по ключу
data := make(map[int]int)
data[123] = 100
data[123] = 200

Можно удалить значение по ключу которого некоторые
data := make(map[int]int)
delete(data, 123)

Нельзя получить адрес значения мапы - т.к. может произойти эвакуация.
data := map[int]int{0: 1}
_ = &data[0]  // error

// ===============================================

    Мап в Go.
    ---------

1. Не хранят данные отсортированные по ключу.
2. Не сохраняют порядок в котором были добавленны данные.
3. Тип ключа словаря должен быть сравниваемым.
4. При итерации порядок не опрнделен.

// ===============================================

    Очистка мапы.
    -------------

1 - способ. Присваиваем словарю nil.
мы звбываем про память словаря. 
GC прийдет и очистит.
data := map[int]int{1: 1, 2: 2, 3: 3}
data = nil

2 - способ. Удаление в цикле. Но бакуты остаются в памяти.
Даже оверфлов бакеты остаются.
data := map[int]int{1: 1, 2: 2, 3: 3}
for key := range data {
    delete(data, key)
}

// ===============================================

