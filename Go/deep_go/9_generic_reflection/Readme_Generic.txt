// T1, T2 - type parameters
func Do[T1 any, T2 any]() {
    // ...
}

// string, int - type arguments
Do[string, int]


Типы парамутры --- типы в объявлении функции

Типы фргументы --- типы переданные при вызове функции

Type inference --- пытается угадать, какой тип вы имели в виду,
    исследуя типы аргументов.

// =====================================

    Основная цель использования дженериков
    ---------------------------------------

избежать повторение кода, или другими словами повысить возможность
повторного использования кода.


// =====================================

Нужно помнить, что дженерики - это не просто синтаксический сахар,
они могут влиять на размер вашего скомпилированного кода.

Потому что каждая специализация дженерик-функции или типа
создает новую версию этой функции или типа для каждого
используемого набора типов.

For example:

type Data[Ta any] struct {
    Value T
}

d1 := Data[int]{}
d2 := Data[uint]{}

// it will be generated to 

type DataInt struct {
    Value int
}

type DataUint struct {
    Value uint
}


// =====================================


    Преимущества.
    -------------

1. Повторное использование кода - дженерики позволяют
создавать гибкие функции и типы данных, которые можно 
использовать с разными типами данных без дублирования кода.

2. Типопезопасность - в отличае от использования пустых тнтерфейсов,
дженерики обеспечивают проверку типов на этапе компиляции,
что уменьшает риск ошибок во время выполнения.

3. Производительность - использование дженериков может улучшить производительность,
так как избавляет от необходимости преобразования типов.

    Недостатки.
    -----------

1. Сложность - синтаксис дженериков может быть
сложнывм для понимания, а также обобщенное программирование может существенно усложнить
структуру кода и его читаемость.

2. Может разростаться бинарник.

3. Может увеличиться время компиляции.


// =====================================

    Что нельзя делать с дженериками?
    ---------------------------------

1. Нельзя написать обобщенный метод структуры.

// constraint
type Signed interface {
	int | int8 | int16 | int32 | int64
}

type Counter struct {
	value int64
}

func (c *Counter) Add[T Signed](value T) { // compilation erro
	c.value += int64(value)
}

2. Можно создать переменную, но нельзя константу.

func process1[T int]() {
	const value T = 5 // compilation error
}

func process2[T int]() {
	var value T = 5 // ok
	_ = value
}


3. 
